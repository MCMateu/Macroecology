{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"This is a macroecology research site","text":"<p>For codes and data availability visit https://github.com/MCMateu.</p>"},{"location":"#what-is-macroecology","title":"What is macroecology?","text":""},{"location":"#why-it-should-interest-you","title":"Why it should interest you?","text":""},{"location":"#about-me","title":"About me","text":"<p>As a PhD student, I am fascinated by the complex role that microbial interactions play in the structure and function of microbial communities. The significance of microbial interactions cannot be overstated, particularly in the context of debilitating conditions such as different types of cancer, Crohn's disease or cystic fibrosis. My ultimate goal is to contribute to the development of a theoretical framework for understanding the dynamics of the microbiome, enabling us to predict the efficacy of microbiome-based medical treatments.</p>"},{"location":"Nonequilibrium/","title":"Non-equilibrium forces decomposition of two species ecosystem","text":"In\u00a0[62]: Copied! <pre>def A(x1, x2,c12,c21,tau1,tau2,K1,K2):\n'''\n    Function that returns the 2D Lotka-Volterra drift\n    '''\n    \n    c11=-1/(tau1*K1)\n    c22=-1/(tau2*K2)\n    \n    N1=x1.size\n    N2=x2.size\n    \n    v1=np.zeros([N1,N2])    \n    v2=np.zeros([N1,N2])  \n    \n    v1=  np.array( (x1)*(1/tau1+c11*x1) ).reshape(-1,1) + (c12/tau1)*np.tensordot(x1,x2,axes=0)\n    v2=  np.array( (x2)*(1/tau2+c22*x2) ) + (c21/tau2)*np.tensordot(x2,x1,axes=0)\n    \n    drift=[v1,v2]\n    \n    return drift\n</pre> def A(x1, x2,c12,c21,tau1,tau2,K1,K2):          '''     Function that returns the 2D Lotka-Volterra drift     '''          c11=-1/(tau1*K1)     c22=-1/(tau2*K2)          N1=x1.size     N2=x2.size          v1=np.zeros([N1,N2])         v2=np.zeros([N1,N2])            v1=  np.array( (x1)*(1/tau1+c11*x1) ).reshape(-1,1) + (c12/tau1)*np.tensordot(x1,x2,axes=0)     v2=  np.array( (x2)*(1/tau2+c22*x2) ) + (c21/tau2)*np.tensordot(x2,x1,axes=0)          drift=[v1,v2]          return drift In\u00a0[63]: Copied! <pre>def FrictionForce(x1,x2,tau1,tau2,s,sigmaNoise1,sigmaNoise2,N1,N2):\n    \n    gamma11=sigmaNoise1/tau1\n    gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s\n    gamma22=sigmaNoise2/tau2\n    \n    ff1=np.zeros([N1,N2])\n    ff2=np.zeros([N1,N2])\n    \n    ff1=0.5*(2.0*gamma11*x1.reshape(-1,1)+gamma12*np.tensordot(x1,x2,axes=0))\n    ff2=0.5*(2.0*gamma22*x2+gamma12*np.tensordot(x1,x2,axes=0))\n    \n    return [ff1,ff2]\n</pre> def FrictionForce(x1,x2,tau1,tau2,s,sigmaNoise1,sigmaNoise2,N1,N2):          gamma11=sigmaNoise1/tau1     gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s     gamma22=sigmaNoise2/tau2          ff1=np.zeros([N1,N2])     ff2=np.zeros([N1,N2])          ff1=0.5*(2.0*gamma11*x1.reshape(-1,1)+gamma12*np.tensordot(x1,x2,axes=0))     ff2=0.5*(2.0*gamma22*x2+gamma12*np.tensordot(x1,x2,axes=0))          return [ff1,ff2] In\u00a0[64]: Copied! <pre>def GradientForce(P,tau1,tau2,s,sigmaNoise1,sigmaNoise2,h,N1,N2,left_border):\n    \n    gamma11=sigmaNoise1/tau1\n    gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s\n    gamma22=sigmaNoise2/tau2\n    \n    VF1=np.zeros([N1,N2])\n    VF2=np.zeros([N1,N2])\n    \n    x2=left_border\n    \n    for j in range(1,N2-1):\n    \n    \tx2=x2+h\n    \tx1=left_border\n    \tfor i in range(1,N1-1):\n           x1=x1+h\n           #Conservative force\n           # if(P[i][j]&gt;1e-4):\n           VF1[i][j]=0.5*(gamma11*x1*x1*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma12*x1*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n           VF2[i][j]=0.5*(gamma12*x1*x2*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma22*x2*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n                \n                \n    return [VF1,VF2]\n</pre> def GradientForce(P,tau1,tau2,s,sigmaNoise1,sigmaNoise2,h,N1,N2,left_border):          gamma11=sigmaNoise1/tau1     gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s     gamma22=sigmaNoise2/tau2          VF1=np.zeros([N1,N2])     VF2=np.zeros([N1,N2])          x2=left_border          for j in range(1,N2-1):          \tx2=x2+h     \tx1=left_border     \tfor i in range(1,N1-1):            x1=x1+h            #Conservative force            # if(P[i][j]&gt;1e-4):            VF1[i][j]=0.5*(gamma11*x1*x1*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma12*x1*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])            VF2[i][j]=0.5*(gamma12*x1*x2*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma22*x2*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])                                       return [VF1,VF2] In\u00a0[65]: Copied! <pre>def CURL(P,v1,v2,tau1,tau2,s,sigmaNoise1,sigmaNoise2,h,N1,N2,left_border):\n'''\n    Function that returns the 2D CURL FORCE: J/P\n    -J Probability Density Current\n    -P Probability Density Function\n    '''\n    \n    J1=np.zeros([N1,N2])\n    J2=np.zeros([N1,N2])\n    \n    gamma11=sigmaNoise1/tau1\n    gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s\n    gamma22=sigmaNoise2/tau2\n    \n    x2=left_border\n    for j in range(1,N2-1):\n        \n        x1=left_border\n        x2=x2+h\n        for i in range(1,N1-1):\n            \n                x1=x1+h\n                \n                drift1=v1[i][j]*P[i][j]\n                noise11=( (x1+h)*(x1+h)*P[i+1][j]-(x1-h)*(x1-h)*P[i-1][j] ) / (2.0*h)\n                noise12=( (x2+h)*P[i][j+1]-(x2-h)*P[i][j-1]) / (2.0*h)\n                \n                J1[i][j]=(drift1-0.5*gamma11*noise11-0.5*gamma12*x1*noise12)\n            \n            \n                drift2=v2[i][j]*P[i][j]\n                noise21=( (x1+h)*P[i+1][j]-(x1-h)*P[i-1][j] ) / (2.0*h)\n                noise22=( (x2+h)*(x2+h)*P[i][j+1]-(x2-h)*(x2-h)*P[i][j-1]) / (2.0*h)\n            \n                J2[i][j]=(drift2-0.5*gamma12*x2*noise21-0.5*gamma22*noise22)\n            \n           \n    current=np.array([J1,J2])\n    \n    return current\n</pre> def CURL(P,v1,v2,tau1,tau2,s,sigmaNoise1,sigmaNoise2,h,N1,N2,left_border):          '''     Function that returns the 2D CURL FORCE: J/P     -J Probability Density Current     -P Probability Density Function     '''          J1=np.zeros([N1,N2])     J2=np.zeros([N1,N2])          gamma11=sigmaNoise1/tau1     gamma12=np.sqrt(sigmaNoise1/tau1)*np.sqrt(sigmaNoise2/tau2)*s     gamma22=sigmaNoise2/tau2          x2=left_border     for j in range(1,N2-1):                  x1=left_border         x2=x2+h         for i in range(1,N1-1):                              x1=x1+h                                  drift1=v1[i][j]*P[i][j]                 noise11=( (x1+h)*(x1+h)*P[i+1][j]-(x1-h)*(x1-h)*P[i-1][j] ) / (2.0*h)                 noise12=( (x2+h)*P[i][j+1]-(x2-h)*P[i][j-1]) / (2.0*h)                                  J1[i][j]=(drift1-0.5*gamma11*noise11-0.5*gamma12*x1*noise12)                                           drift2=v2[i][j]*P[i][j]                 noise21=( (x1+h)*P[i+1][j]-(x1-h)*P[i-1][j] ) / (2.0*h)                 noise22=( (x2+h)*(x2+h)*P[i][j+1]-(x2-h)*(x2-h)*P[i][j-1]) / (2.0*h)                              J2[i][j]=(drift2-0.5*gamma12*x2*noise21-0.5*gamma22*noise22)                              current=np.array([J1,J2])          return current In\u00a0[66]: Copied! <pre>##############################\n#        LIBRARIES           #\n############################## \nimport numpy as np\nimport math as mt\nimport pandas as pd\nimport os\nfrom matplotlib import pyplot as plt\nfrom matplotlib.colors import LinearSegmentedColormap\nimport nums_from_string\n</pre> ############################## #        LIBRARIES           # ##############################  import numpy as np import math as mt import pandas as pd import os from matplotlib import pyplot as plt from matplotlib.colors import LinearSegmentedColormap import nums_from_string <p>The data of $P(x,y)$ is saved in MainFolder. This folder contains a folder with the values of the paremeters used during the simulation:</p> In\u00a0[67]: Copied! <pre>#Main Folder\nMainFolder=\"/home/jose/MEGA/EcologicalForces/2D_CURRENTS/P-data\"\n\nParameters_Folders=os.listdir(MainFolder)\n\nFolder_num=1 #in my case is the element 1 in the folder\n\nprint(Parameters_Folders[Folder_num])\n</pre> #Main Folder MainFolder=\"/home/jose/MEGA/EcologicalForces/2D_CURRENTS/P-data\"  Parameters_Folders=os.listdir(MainFolder)  Folder_num=1 #in my case is the element 1 in the folder  print(Parameters_Folders[Folder_num]) <pre>muNoise_0_sigmaNoise_0.3_tau_1_K_1\n</pre> <p>Now we can extract the paramters used in the simulation from the name of the folder:</p> In\u00a0[68]: Copied! <pre>##############################\n#        PARAMETERS          #\n##############################\n\nParameters=np.array(nums_from_string.get_nums(Parameters_Folders[Folder_num]))\n\nmuNoise=Parameters[0] #mean of the Gaussian white noise\nsigmaNoise=Parameters[1] #standart deviation of the Gaussian white noise\ntau=Parameters[2] #dynamics scale\nK=Parameters[3] #maximum carrying capacity\n\ninteraction_files=os.listdir(MainFolder+\"/\"+Parameters_Folders[Folder_num])\n\nfile_num=1\n\ninteractions=np.array(nums_from_string.get_nums(interaction_files[file_num]))\n\ns=interactions[0] #resources fluctuation\nc12=interactions[1] #interaction 1-&gt;2\nc21=interactions[2] #interaction 2-&gt;1\nK1=1\nK2=1\n\n#Ito vs Stratonovich\nalpha=0.5\nH1=(alpha-0.5)*sigmaNoise+1.0\nH2=(alpha-0.5)*sigmaNoise+1.0\n\n#fixed point\nx1star=(H1*K1*K2*c12+H2*K1)/(1-K1*K2*c12*c21)\nx2star=(H2*K1*K2*c21+H1*K2)/(1-K1*K2*c12*c21)\n</pre> ############################## #        PARAMETERS          # ##############################  Parameters=np.array(nums_from_string.get_nums(Parameters_Folders[Folder_num]))  muNoise=Parameters[0] #mean of the Gaussian white noise sigmaNoise=Parameters[1] #standart deviation of the Gaussian white noise tau=Parameters[2] #dynamics scale K=Parameters[3] #maximum carrying capacity  interaction_files=os.listdir(MainFolder+\"/\"+Parameters_Folders[Folder_num])  file_num=1  interactions=np.array(nums_from_string.get_nums(interaction_files[file_num]))  s=interactions[0] #resources fluctuation c12=interactions[1] #interaction 1-&gt;2 c21=interactions[2] #interaction 2-&gt;1 K1=1 K2=1  #Ito vs Stratonovich alpha=0.5 H1=(alpha-0.5)*sigmaNoise+1.0 H2=(alpha-0.5)*sigmaNoise+1.0  #fixed point x1star=(H1*K1*K2*c12+H2*K1)/(1-K1*K2*c12*c21) x2star=(H2*K1*K2*c21+H1*K2)/(1-K1*K2*c12*c21) <p>Data load:</p> In\u00a0[69]: Copied! <pre>####################################\n#            READ DATA             #\n####################################\n\n#read data file\nf=np.loadtxt(MainFolder+\"/\"+Parameters_Folders[Folder_num]+\"/\"+interaction_files[file_num])\n\nN=int(len(np.unique(f[:,0])))\nright_border=np.round(f[N-1,0])\nleft_border=f[0,0]\nh=(right_border-left_border)/(1.0*N);\n</pre> #################################### #            READ DATA             # ####################################  #read data file f=np.loadtxt(MainFolder+\"/\"+Parameters_Folders[Folder_num]+\"/\"+interaction_files[file_num])  N=int(len(np.unique(f[:,0]))) right_border=np.round(f[N-1,0]) left_border=f[0,0] h=(right_border-left_border)/(1.0*N);   <p>The resulting data is long-format we need to convert to wide-format (matrix-like:), for this I propose following dummy code:</p> In\u00a0[70]: Copied! <pre>#Declare Probability Density Function\nP=np.empty([N,N],float)\n\n#save P data in a matrix\nk=0\nmaxP=0.0\nxPmax=0.0\nyPmax=0.0\nnorm=0.0\nfor j in range(0,N):\n\n\tfor i in range(0,N):\n\t\n\t\tP[i][j]=abs(f[k][2])\n\t\tnorm=norm+P[i][j]*h*h\n\t\tk=k+1\n\t\tif(maxP&lt;P[i][j]):\n\t\t\tmaxP=P[i][j]\n\t\t\txPmax=f[k][0]\n\t\t\tyPmax=f[k][1]\n</pre> #Declare Probability Density Function P=np.empty([N,N],float)  #save P data in a matrix k=0 maxP=0.0 xPmax=0.0 yPmax=0.0 norm=0.0 for j in range(0,N):  \tfor i in range(0,N): \t \t\tP[i][j]=abs(f[k][2]) \t\tnorm=norm+P[i][j]*h*h \t\tk=k+1 \t\tif(maxP <p>Plot:</p> In\u00a0[71]: Copied! <pre>####################################\n#            PLOT GRID             #\n####################################\n\nnrow=1\nncol=4\n\nfig, axs = plt.subplots(nrow, ncol,sharex=True,sharey=True,figsize=(16,8))\n\n\nfig.subplots_adjust(wspace=0.1, hspace=0.1)\n\n#CREATE GRID\ny,x = np.meshgrid(np.linspace(h,right_border,N),np.linspace(h,right_border,N))\n\n\n################\n#ABUNDANCE GRID#\n################\n\nx1=np.arange(left_border,right_border,h,dtype=\"double\")\nx2=np.arange(left_border,right_border,h,dtype=\"double\")\n\n#######\n#DRIFT#\n#######\nax1=axs[0]\n\n#DRIFT\n[A1,A2]=A(x1,x2,c12,c21,tau,tau,K,K)\n\n#Module\nmodule_DRIFT=np.sqrt(A1*A1+A2*A2)\n\n#Stream plot\nstrm1=ax1.streamplot(y, x, A2,A1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)\n\n#Plot module as a color map in the background\nticks = np.round( np.linspace(module_DRIFT.min(),4, 5, endpoint=True),0 )\nLevels = np.round( np.linspace(module_DRIFT.min(),4, 20, endpoint=True),1 )\npcm1=ax1.contourf(y[0:350,0:350], x[0:350,0:350], module_DRIFT[0:350,0:350],levels=Levels,cmap=\"rainbow\")\ncbar1=fig.colorbar(pcm1, ax=ax1,orientation=\"horizontal\",ticks=ticks,pad=0.1)\ncbar1.set_label(label=r'$|\\vec{A}|$',fontsize=14,fontname=\"Roboto\")\n#Plot fixed point\nax1.plot(x2star,x1star,'o', markersize=15,color=\"orange\", markeredgewidth=4,markeredgecolor=\"black\")\n\n#Plot fixed points\nax1.set_xlim(0.5,2.5)\nax1.set_ylim(0.5,2.5)\n\nax1.title.set_text(\"Drift Force\")\nax1.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\")\nax1.set_ylabel(r'$x_{1}$',fontsize=14,fontname=\"Roboto\",color=\"black\")\nax1.text(0.4,2.6,r\"$a)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")\n\n################\n#GRADIENT FORCE#\n################\nax2=axs[1]\n\n[GF1,GF2]=GradientForce(P,tau,tau,s,sigmaNoise,sigmaNoise,h,N,N,left_border)\n\n#REMOVE ANOMALIES: NaN &amp; inf\nGF1[np.isnan(GF1)==True]=0\nGF1[np.isinf(GF1)==True]=0\nGF2[np.isnan(GF2)==True]=0\nGF2[np.isinf(GF2)==True]=0\n#REMOVE NUMERICAL INFINITIES\nGF1[abs(GF1)&gt;6]=0\nGF2[abs(GF2)&gt;6]=0\n\n#Module\nmodule_GF=np.sqrt(GF1*GF1+GF2*GF2)\n\n#Stream plot\nstrm2=ax2.streamplot(y, x, GF2, GF1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)\n\n#Plot module as a color map in the background\nticks = np.round( np.linspace(module_GF.min(),10, 5, endpoint=True) , 0)\nLevels = np.round( np.linspace(module_GF.min(),10, 20, endpoint=True) , 1)\npcm2=ax2.contourf(y[0:350,0:350], x[0:350,0:350], module_GF[0:350,0:350],levels=Levels,cmap=\"rainbow\")\ncbar2=fig.colorbar(pcm2, ax=ax2,orientation=\"horizontal\",ticks=ticks,pad=0.1)\ncbar2.set_label(label=r'$|\\frac{1}{2}D\\nabla log \\left(P\\right)|$',fontsize=14,fontname=\"Roboto\")\n\n#Plot maximum probability\nax2.plot(yPmax,xPmax,'s', markersize=15,color=\"red\",markeredgewidth=4,markeredgecolor=\"black\")\n\n#Plot fixed points\nax2.set_xlim(0.5,2.5)\nax2.set_ylim(0.5,2.5)\n\nax2.title.set_text(\"Gradient Force\")\nax2.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\")\nax2.text(0.4,2.6,r\"$b)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")\n###############\n#DRAGGIN FORCE#\n###############\n\nax3=axs[2]\n\n[ff1,ff2]=FrictionForce(x1,x2,tau,tau,s,sigmaNoise,sigmaNoise,N,N)\n\n#Module\nmodule_ff=np.sqrt(ff1*ff1+ff2*ff2)\n\n#CONVECTIVE FIELD\n#[C1,C2]=[A1-ff1,A2-ff2]\n\n#Stream plot\nstrm3=ax3.streamplot(y, x, ff2, ff1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)\n\n#Plot module as a color map in the background\nticks = np.round( np.linspace(module_ff.min(),2, 6, endpoint=True) , 0)\nLevels = np.round( np.linspace(module_ff.min(),2, 20, endpoint=True) , 1)\npcm3=ax3.contourf(y[0:350,0:350], x[0:350,0:350], module_ff[0:350,0:350],levels=Levels,cmap=\"rainbow\")\ncbar3=fig.colorbar(pcm3, ax=ax3,orientation=\"horizontal\",ticks=ticks,pad=0.1)\ncbar3.set_label(label=r'$|\\frac{1}{2}\\sum_j \\partial_j D_{ij}|$',fontsize=14,fontname=\"Roboto\")\n#Plot fixed points\n#Plot fixed point\n#ax3.plot(x2star,x1star,'bo', markersize=15,color=\"red\", markeredgewidth=4,markeredgecolor=\"black\")\n\nax3.set_xlim(0.5,2.5)\nax3.set_ylim(0.5,2.5)\nax3.title.set_text(\"Dragging Force\")\nax3.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\")\nax3.text(0.4,2.6,r\"$c)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")\n############\n#CURL FORCE#\n############\nax4=axs[3]\n\n[CURL1,CURL2]=CURL(P,A1,A2,tau,tau,s,sigmaNoise,sigmaNoise,h,N,N,left_border)\n\n#REMOVE ANOMALIES: NaN &amp; inf\nCURL1[np.isnan(CURL1)==True]=0\nCURL1[np.isinf(CURL1)==True]=0\nCURL2[np.isnan(CURL2)==True]=0\nCURL2[np.isinf(CURL2)==True]=0\n#REMOVE NUMERICAL INFINITIES\nCURL1[abs(CURL1)&gt;0.3]=0\nCURL2[abs(CURL2)&gt;0.3]=0\n\n#Module\nmodule_CURL=np.sqrt(CURL1*CURL1+CURL2*CURL2)\n\n#Stream plot\nstrm4=ax4.streamplot(y, x, CURL2, CURL1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)\n\n#Plot module as a color map in the background\nticks = np.round( np.linspace(1e-3,module_CURL.max(), 6, endpoint=True), 3 )\nLevels = np.round( np.linspace(module_CURL.min(),module_CURL.max(), 20, endpoint=True), 3 )\npcm4=ax4.contourf(y[0:350,0:350], x[0:350,0:350], module_CURL[0:350,0:350],levels=Levels,cmap=\"rainbow\")\ncbar4=fig.colorbar(pcm4, ax=ax4,orientation=\"horizontal\",ticks=ticks,pad=0.1,format='%.e')\ncbar4.set_label(label=r'$|\\vec{J}|$',fontsize=14,fontname=\"Roboto\")\n#Plot maximum probability\nax4.plot(yPmax,xPmax,'s', markersize=15,color=\"red\",markeredgewidth=4,markeredgecolor=\"black\")\n\n#Plot fixed points\nax4.set_xlim(0.5,2.5)\nax4.set_ylim(0.5,2.5)\n\nax4.title.set_text(\"Probability Density Current\")\nax4.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\")\nax4.text(0.4,2.6,r\"$d)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")\n</pre> #################################### #            PLOT GRID             # ####################################  nrow=1 ncol=4  fig, axs = plt.subplots(nrow, ncol,sharex=True,sharey=True,figsize=(16,8))   fig.subplots_adjust(wspace=0.1, hspace=0.1)  #CREATE GRID y,x = np.meshgrid(np.linspace(h,right_border,N),np.linspace(h,right_border,N))   ################ #ABUNDANCE GRID# ################  x1=np.arange(left_border,right_border,h,dtype=\"double\") x2=np.arange(left_border,right_border,h,dtype=\"double\")  ####### #DRIFT# ####### ax1=axs[0]  #DRIFT [A1,A2]=A(x1,x2,c12,c21,tau,tau,K,K)  #Module module_DRIFT=np.sqrt(A1*A1+A2*A2)  #Stream plot strm1=ax1.streamplot(y, x, A2,A1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)  #Plot module as a color map in the background ticks = np.round( np.linspace(module_DRIFT.min(),4, 5, endpoint=True),0 ) Levels = np.round( np.linspace(module_DRIFT.min(),4, 20, endpoint=True),1 ) pcm1=ax1.contourf(y[0:350,0:350], x[0:350,0:350], module_DRIFT[0:350,0:350],levels=Levels,cmap=\"rainbow\") cbar1=fig.colorbar(pcm1, ax=ax1,orientation=\"horizontal\",ticks=ticks,pad=0.1) cbar1.set_label(label=r'$|\\vec{A}|$',fontsize=14,fontname=\"Roboto\") #Plot fixed point ax1.plot(x2star,x1star,'o', markersize=15,color=\"orange\", markeredgewidth=4,markeredgecolor=\"black\")  #Plot fixed points ax1.set_xlim(0.5,2.5) ax1.set_ylim(0.5,2.5)  ax1.title.set_text(\"Drift Force\") ax1.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\") ax1.set_ylabel(r'$x_{1}$',fontsize=14,fontname=\"Roboto\",color=\"black\") ax1.text(0.4,2.6,r\"$a)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")  ################ #GRADIENT FORCE# ################ ax2=axs[1]  [GF1,GF2]=GradientForce(P,tau,tau,s,sigmaNoise,sigmaNoise,h,N,N,left_border)  #REMOVE ANOMALIES: NaN &amp; inf GF1[np.isnan(GF1)==True]=0 GF1[np.isinf(GF1)==True]=0 GF2[np.isnan(GF2)==True]=0 GF2[np.isinf(GF2)==True]=0 #REMOVE NUMERICAL INFINITIES GF1[abs(GF1)&gt;6]=0 GF2[abs(GF2)&gt;6]=0  #Module module_GF=np.sqrt(GF1*GF1+GF2*GF2)  #Stream plot strm2=ax2.streamplot(y, x, GF2, GF1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)  #Plot module as a color map in the background ticks = np.round( np.linspace(module_GF.min(),10, 5, endpoint=True) , 0) Levels = np.round( np.linspace(module_GF.min(),10, 20, endpoint=True) , 1) pcm2=ax2.contourf(y[0:350,0:350], x[0:350,0:350], module_GF[0:350,0:350],levels=Levels,cmap=\"rainbow\") cbar2=fig.colorbar(pcm2, ax=ax2,orientation=\"horizontal\",ticks=ticks,pad=0.1) cbar2.set_label(label=r'$|\\frac{1}{2}D\\nabla log \\left(P\\right)|$',fontsize=14,fontname=\"Roboto\")  #Plot maximum probability ax2.plot(yPmax,xPmax,'s', markersize=15,color=\"red\",markeredgewidth=4,markeredgecolor=\"black\")  #Plot fixed points ax2.set_xlim(0.5,2.5) ax2.set_ylim(0.5,2.5)  ax2.title.set_text(\"Gradient Force\") ax2.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\") ax2.text(0.4,2.6,r\"$b)$\",fontsize=18,fontname=\"Roboto\",color=\"black\") ############### #DRAGGIN FORCE# ###############  ax3=axs[2]  [ff1,ff2]=FrictionForce(x1,x2,tau,tau,s,sigmaNoise,sigmaNoise,N,N)  #Module module_ff=np.sqrt(ff1*ff1+ff2*ff2)  #CONVECTIVE FIELD #[C1,C2]=[A1-ff1,A2-ff2]  #Stream plot strm3=ax3.streamplot(y, x, ff2, ff1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)  #Plot module as a color map in the background ticks = np.round( np.linspace(module_ff.min(),2, 6, endpoint=True) , 0) Levels = np.round( np.linspace(module_ff.min(),2, 20, endpoint=True) , 1) pcm3=ax3.contourf(y[0:350,0:350], x[0:350,0:350], module_ff[0:350,0:350],levels=Levels,cmap=\"rainbow\") cbar3=fig.colorbar(pcm3, ax=ax3,orientation=\"horizontal\",ticks=ticks,pad=0.1) cbar3.set_label(label=r'$|\\frac{1}{2}\\sum_j \\partial_j D_{ij}|$',fontsize=14,fontname=\"Roboto\") #Plot fixed points #Plot fixed point #ax3.plot(x2star,x1star,'bo', markersize=15,color=\"red\", markeredgewidth=4,markeredgecolor=\"black\")  ax3.set_xlim(0.5,2.5) ax3.set_ylim(0.5,2.5) ax3.title.set_text(\"Dragging Force\") ax3.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\") ax3.text(0.4,2.6,r\"$c)$\",fontsize=18,fontname=\"Roboto\",color=\"black\") ############ #CURL FORCE# ############ ax4=axs[3]  [CURL1,CURL2]=CURL(P,A1,A2,tau,tau,s,sigmaNoise,sigmaNoise,h,N,N,left_border)  #REMOVE ANOMALIES: NaN &amp; inf CURL1[np.isnan(CURL1)==True]=0 CURL1[np.isinf(CURL1)==True]=0 CURL2[np.isnan(CURL2)==True]=0 CURL2[np.isinf(CURL2)==True]=0 #REMOVE NUMERICAL INFINITIES CURL1[abs(CURL1)&gt;0.3]=0 CURL2[abs(CURL2)&gt;0.3]=0  #Module module_CURL=np.sqrt(CURL1*CURL1+CURL2*CURL2)  #Stream plot strm4=ax4.streamplot(y, x, CURL2, CURL1,linewidth=2, color=\"black\", density=1.5, arrowsize=1.5)  #Plot module as a color map in the background ticks = np.round( np.linspace(1e-3,module_CURL.max(), 6, endpoint=True), 3 ) Levels = np.round( np.linspace(module_CURL.min(),module_CURL.max(), 20, endpoint=True), 3 ) pcm4=ax4.contourf(y[0:350,0:350], x[0:350,0:350], module_CURL[0:350,0:350],levels=Levels,cmap=\"rainbow\") cbar4=fig.colorbar(pcm4, ax=ax4,orientation=\"horizontal\",ticks=ticks,pad=0.1,format='%.e') cbar4.set_label(label=r'$|\\vec{J}|$',fontsize=14,fontname=\"Roboto\") #Plot maximum probability ax4.plot(yPmax,xPmax,'s', markersize=15,color=\"red\",markeredgewidth=4,markeredgecolor=\"black\")  #Plot fixed points ax4.set_xlim(0.5,2.5) ax4.set_ylim(0.5,2.5)  ax4.title.set_text(\"Probability Density Current\") ax4.set_xlabel(r'$x_{2}$',fontsize=14,fontname=\"Roboto\",color=\"black\") ax4.text(0.4,2.6,r\"$d)$\",fontsize=18,fontname=\"Roboto\",color=\"black\")  <pre>/tmp/ipykernel_76619/758981523.py:20: RuntimeWarning: invalid value encountered in double_scalars\n  VF1[i][j]=0.5*(gamma11*x1*x1*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma12*x1*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n/tmp/ipykernel_76619/758981523.py:21: RuntimeWarning: invalid value encountered in double_scalars\n  VF2[i][j]=0.5*(gamma12*x1*x2*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma22*x2*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n/tmp/ipykernel_76619/758981523.py:21: RuntimeWarning: divide by zero encountered in double_scalars\n  VF2[i][j]=0.5*(gamma12*x1*x2*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma22*x2*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n/tmp/ipykernel_76619/758981523.py:20: RuntimeWarning: divide by zero encountered in double_scalars\n  VF1[i][j]=0.5*(gamma11*x1*x1*(P[i+1][j]-P[i-1][j])/(2.0*h)+gamma12*x1*x2*(P[i][j+1]-P[i][j-1])/(2.0*h))/(P[i][j])\n</pre> Out[71]: <pre>Text(0.4, 2.6, '$d)$')</pre>"},{"location":"Nonequilibrium/#non-equilibrium-forces-decomposition-of-two-species-ecosystem","title":"Non-equilibrium forces decomposition of two species ecosystem\u00b6","text":""},{"location":"Nonequilibrium/#introduction","title":"Introduction\u00b6","text":"<p>Understanding the ecological forces that shapes microbial communities is a fundamental problem in ecology.</p>"},{"location":"Nonequilibrium/#friction-force","title":"Friction Force\u00b6","text":""},{"location":"Nonequilibrium/#gradient-force","title":"Gradient Force\u00b6","text":"$$ \\boldsymbol{D} \\nabla log(P)= \\begin{pmatrix} D_{11} &amp; D_{12} \\\\ D_{21} &amp; D_{22} \\end{pmatrix} \\cdot \\begin{pmatrix} \\partial_{x} log(P) \\\\ \\partial_{y} log(P) \\end{pmatrix} $$"},{"location":"Nonequilibrium/#curl-force","title":"Curl Force\u00b6","text":""},{"location":"Nonequilibrium/#plot","title":"Plot\u00b6","text":"<p>First let us start by importing the libraries:</p>"},{"location":"Synthetic-Communities/","title":"Programing in silico microbiomes","text":"In\u00a0[2]: Copied! <pre>def StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S):\n\"\"\"\n    Stochastic Logistic equation (SLM) solution by Euler-Maruyama method;\n    INPUT\n    - K (float): carrying capacitities;\n    - tau (float): intrinsic growth time;\n    - sigmaNoise (float): variance of the Gaussian noise;\n    - muNoise (float): mean value of the Gaussian noise;\n    - nSim (float): number of simulation;\n    - timeList (1d array): list of T time instants;\n    - abundanceStart (float): initial abundance;\n    - S (float): number of species;\n    OUTPUT\n    - longitudinal (T x S array): abundance of the species j at time i;\n    - crossSectional (S x nSim array): abundance of the k trajectory at the last time for the j trajectory;\n    \"\"\"\n    \n    #initial state\n    x0 = np.full(S,abundanceStart)\n\n    #simulation loop\n\n    abundanceMat = np.zeros((timeList.size,S,nSim),dtype=float)\n    \n    dt = round((timeList[-1]-timeList[0])/(len(timeList)),2)\n    \n    for sim in range(nSim):\n        \n        abundanceMat[0,:,sim] = x0\n        \n        #time loop\n        for t in range(1,timeList.size):\n\n            #dynamics\n            x = abundanceMat[t-1,:,sim]\n            noise = muNoise+np.sqrt(sigmaNoise/tau)*np.random.normal(0,1,size=(S)) #Gaussian noise\n            xt = x+x*dt/tau-x**2/(tau*K)*dt+(noise*x*mt.sqrt(dt)) #equation\n        \n            abundanceMat[t,:,sim]=np.round(xt,5)\n    \n    longitudinal = abundanceMat[:,:,0]\n    crossSectional = abundanceMat[-1,:,:]\n    \n    return([longitudinal,crossSectional])\n</pre> def StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S):          \"\"\"     Stochastic Logistic equation (SLM) solution by Euler-Maruyama method;          INPUT     - K (float): carrying capacitities;     - tau (float): intrinsic growth time;     - sigmaNoise (float): variance of the Gaussian noise;     - muNoise (float): mean value of the Gaussian noise;     - nSim (float): number of simulation;     - timeList (1d array): list of T time instants;     - abundanceStart (float): initial abundance;     - S (float): number of species;          OUTPUT     - longitudinal (T x S array): abundance of the species j at time i;     - crossSectional (S x nSim array): abundance of the k trajectory at the last time for the j trajectory;     \"\"\"          #initial state     x0 = np.full(S,abundanceStart)      #simulation loop      abundanceMat = np.zeros((timeList.size,S,nSim),dtype=float)          dt = round((timeList[-1]-timeList[0])/(len(timeList)),2)          for sim in range(nSim):                  abundanceMat[0,:,sim] = x0                  #time loop         for t in range(1,timeList.size):              #dynamics             x = abundanceMat[t-1,:,sim]             noise = muNoise+np.sqrt(sigmaNoise/tau)*np.random.normal(0,1,size=(S)) #Gaussian noise             xt = x+x*dt/tau-x**2/(tau*K)*dt+(noise*x*mt.sqrt(dt)) #equation                      abundanceMat[t,:,sim]=np.round(xt,5)          longitudinal = abundanceMat[:,:,0]     crossSectional = abundanceMat[-1,:,:]          return([longitudinal,crossSectional]) <p>Let's start with the simple case of a single species: $S=1$ and see the result. In the following code I fix the parameters of the simulation:</p> In\u00a0[3]: Copied! <pre>##################\n#    LIBRARIES   #\n##################\nimport numpy as np\nimport math as mt\nfrom matplotlib import pyplot as plt\n\n#############################\n#   SIMULATION PARAMETERS   #\n#############################\n\nS=1 #total number of species\ntau=0.1  #time-scale of basal population growth\nK=1 #maximum carrying capacity\nmuNoise=0 #mean of the environmental fluctuations\nsigmaNoise=0.05 #strength of the environmental fluctuations\nnSim = 1 #total number of simulations\nabundanceStart=0.1 \n\n#time\ntStart = 0\ntEnd = 2\ndt = 0.01\ntimeList = np.arange(tStart,tEnd+dt,dt)\n</pre> ################## #    LIBRARIES   # ################## import numpy as np import math as mt from matplotlib import pyplot as plt  ############################# #   SIMULATION PARAMETERS   # #############################  S=1 #total number of species tau=0.1  #time-scale of basal population growth K=1 #maximum carrying capacity muNoise=0 #mean of the environmental fluctuations sigmaNoise=0.05 #strength of the environmental fluctuations nSim = 1 #total number of simulations abundanceStart=0.1   #time tStart = 0 tEnd = 2 dt = 0.01 timeList = np.arange(tStart,tEnd+dt,dt) <p>Then we can call the function we created before StochasticLogisticModel to run a simulation</p> In\u00a0[4]: Copied! <pre>#Run simulations\n[longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)\n\n#########################\n#          PLOT         #\n#########################\n\nplt.plot(timeList,longitudinal,color=\"orange\",linewidth=3,zorder=3)\nplt.xlim(0,2)\nplt.grid(\"on\",color=\"#8ccde3\",linewidth=3.0,zorder=0) #add a blue grid\nplt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label\nplt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label\nplt.title(\"StochasticLogisticModel\",fontweight='bold') #set title\n</pre> #Run simulations [longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)  ######################### #          PLOT         # #########################  plt.plot(timeList,longitudinal,color=\"orange\",linewidth=3,zorder=3) plt.xlim(0,2) plt.grid(\"on\",color=\"#8ccde3\",linewidth=3.0,zorder=0) #add a blue grid plt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label plt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label plt.title(\"StochasticLogisticModel\",fontweight='bold') #set title Out[4]: <pre>Text(0.5, 1.0, 'StochasticLogisticModel')</pre> In\u00a0[104]: Copied! <pre>tau=0.1\nepsilon=0.01 #set a small epsilon (distance to the asymptote)\nt_star = tau*np.log( ( (K-epsilon)/ epsilon ) * (K/abundanceStart-1)  )\n\n#Run simulations\n[longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)\n\n#########################\n#          PLOT         #\n#########################\n\n#plot in red the transitory regimen and in blue the stationary one\nplt.axvspan(0, t_star, alpha=0.2, color='red',zorder=0)\nplt.axvspan(t_star,tEnd, alpha=0.2, color='blue',zorder=0)\n#add vertical line in t_star\nplt.axvline(x = t_star,color=\"black\",linewidth=2.0,linestyle=\"--\") \n\n#plot trajectory\nplt.plot(timeList,longitudinal,color=\"orange\",linewidth=3,zorder=3) \n\nplt.xlim(0,2)\nplt.ylim(0,1.75)\nplt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label\nplt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label\nplt.title(\"StochasticLogisticModel\",fontweight='bold') #set title\nplt.text(x=0.15,y=1.5,s=\"Transitory\",fontweight='bold',fontsize=14,bbox=dict(boxstyle=\"round\",ec=\"black\",fc=\"white\"))\nplt.text(x=1.25,y=1.5,s=\"Steady\",fontweight='bold',fontsize=14,bbox=dict(boxstyle=\"round\",ec=\"black\",fc=\"white\"))\n</pre> tau=0.1 epsilon=0.01 #set a small epsilon (distance to the asymptote) t_star = tau*np.log( ( (K-epsilon)/ epsilon ) * (K/abundanceStart-1)  )  #Run simulations [longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)  ######################### #          PLOT         # #########################  #plot in red the transitory regimen and in blue the stationary one plt.axvspan(0, t_star, alpha=0.2, color='red',zorder=0) plt.axvspan(t_star,tEnd, alpha=0.2, color='blue',zorder=0) #add vertical line in t_star plt.axvline(x = t_star,color=\"black\",linewidth=2.0,linestyle=\"--\")   #plot trajectory plt.plot(timeList,longitudinal,color=\"orange\",linewidth=3,zorder=3)   plt.xlim(0,2) plt.ylim(0,1.75) plt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label plt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label plt.title(\"StochasticLogisticModel\",fontweight='bold') #set title plt.text(x=0.15,y=1.5,s=\"Transitory\",fontweight='bold',fontsize=14,bbox=dict(boxstyle=\"round\",ec=\"black\",fc=\"white\")) plt.text(x=1.25,y=1.5,s=\"Steady\",fontweight='bold',fontsize=14,bbox=dict(boxstyle=\"round\",ec=\"black\",fc=\"white\")) Out[104]: <pre>Text(1.25, 1.5, 'Steady')</pre> <p>The time it takes to reach the steady state also depends on the intrinsic growth time $\\tau$:</p> In\u00a0[105]: Copied! <pre>epsilon=0.01 #set a small epsilon (distance to the asymptote)\n\ntau_list=[0.05,0.1,0.2]\ncolor_list=[\"#7678ed\",\"#f7b801\",\"#f35b04\"]\n\nfor k,tau in enumerate(tau_list):\n\n    t_star = tau*np.log( ( (K-epsilon)/ epsilon ) * (K/abundanceStart-1)  )\n\n    #Run simulations\n    [longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)\n\n    #########################\n    #          PLOT         #\n    #########################\n\n    #add vertical line in t_star\n    plt.axvline(x = t_star,color=color_list[k],linewidth=2.0,linestyle=\"--\") \n\n    #plot trajectory\n    plt.plot(timeList,longitudinal,color=color_list[k],linewidth=3,zorder=3) \n\n    plt.xlim(0,2)\n    plt.ylim(0,1.75)\n    plt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label\n    plt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label\n    plt.title(\"StochasticLogisticModel\",fontweight='bold') #set title\n\nplt.grid(\"on\",color=\"#8ccde3\",linewidth=2.0,zorder=0) #add a blue grid\n</pre> epsilon=0.01 #set a small epsilon (distance to the asymptote)  tau_list=[0.05,0.1,0.2] color_list=[\"#7678ed\",\"#f7b801\",\"#f35b04\"]  for k,tau in enumerate(tau_list):      t_star = tau*np.log( ( (K-epsilon)/ epsilon ) * (K/abundanceStart-1)  )      #Run simulations     [longitudinal,crossSectional]=StochasticLogisticModel (K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S)      #########################     #          PLOT         #     #########################      #add vertical line in t_star     plt.axvline(x = t_star,color=color_list[k],linewidth=2.0,linestyle=\"--\")       #plot trajectory     plt.plot(timeList,longitudinal,color=color_list[k],linewidth=3,zorder=3)       plt.xlim(0,2)     plt.ylim(0,1.75)     plt.xlabel(\"Simulated Time\",fontweight='bold',fontsize=14) #add x-label     plt.ylabel(\"Abudance: x\",fontweight='bold',fontsize=14) #add y-label     plt.title(\"StochasticLogisticModel\",fontweight='bold') #set title  plt.grid(\"on\",color=\"#8ccde3\",linewidth=2.0,zorder=0) #add a blue grid   <p>As before, we create a python function to integrate the model using the Euler-Maruyama method:</p> In\u00a0[106]: Copied! <pre>def InteractionMatrix_LNDiagonal (S,C,muLN,sigmaLN,muInt,sigmaInt):\n\"\"\"\n    Interaction matrix with LogNormal (LN) diagonal and Gaussian off-diagonal fluctuations;\n    INPUT\n    - S (float): species number;\n    - C (float): connectance;\n    - muLN (float): LN mean of the diagonal elements; \n    - sigmaLN (float): LN widths of the diagonal elements;\n    - muInt (float): Gaussian mean of the off-diagonal elements;\n    - sigmaInt (float): Gaussian variance of the off-diagonal elements;\n    OUTPUT\n    - M (SxS array): i,j element provides the interaction weight between the species i and j\n    \"\"\"\n    \n    #interaction\n    A = np.random.normal(muInt,sigmaInt,size=(S,S))\n    \n    #connectance\n    boolMat = np.random.uniform(0,1,size=(S,S))\n    A = (boolMat&lt;C).astype(int)*A\n    A = A-np.diag( np.diag(A) )\n    \n    #diagonal\n    K = 1/np.random.lognormal(muLN,sigmaLN,size=S)\n    M = A-np.diag(K)\n    \n    return(M)\n</pre> def InteractionMatrix_LNDiagonal (S,C,muLN,sigmaLN,muInt,sigmaInt):          \"\"\"     Interaction matrix with LogNormal (LN) diagonal and Gaussian off-diagonal fluctuations;          INPUT     - S (float): species number;     - C (float): connectance;     - muLN (float): LN mean of the diagonal elements;      - sigmaLN (float): LN widths of the diagonal elements;     - muInt (float): Gaussian mean of the off-diagonal elements;     - sigmaInt (float): Gaussian variance of the off-diagonal elements;          OUTPUT     - M (SxS array): i,j element provides the interaction weight between the species i and j     \"\"\"          #interaction     A = np.random.normal(muInt,sigmaInt,size=(S,S))          #connectance     boolMat = np.random.uniform(0,1,size=(S,S))     A = (boolMat"},{"location":"Synthetic-Communities/#programing-in-silico-microbiomes","title":"Programing in silico microbiomes\u00b6","text":""},{"location":"Synthetic-Communities/#introduction","title":"Introduction\u00b6","text":"<p>The microbial abundance series of the metagenomic data strognly resembles us to the trajectories that a random walk may generate. This suggest using Stochastic Differential Equations (SDEs) to model the experimental data.</p> <p>In this tutorial we will learn how to simulate in silico microbiomes by means of the Stochastic Lotka-Volterra model including an environmental filter term:</p> $$ \\dot{x}_i=\\frac{x_i}{\\tau_i}\\left(1-\\frac{x_i}{K_i}+\\sum^S_{i\\neq j}c_{ij}x_j\\right)+\\sqrt{\\frac{\\sigma_i}{\\tau_i}}x_i\\xi_i (t) $$<p>where:</p> <ul> <li>$S$: total number of species</li> <li>$\\tau_i$: is the time scale of basal population growth</li> <li>$K_i$: is the maximum carrying capacity</li> <li>$(c_{ij})=\\hat{C}$: is the Lotka-Volterra interaction matrix</li> <li>$\\xi_i$: is a zero-mean Gaussian noise with correlations $\\langle \\xi_i (t) \\xi_j (t^\\prime ) \\rangle =s_{ij} \\delta(t-t^\\prime)$ --aimed to describe environmental fluctuations--</li> <li>$s_{ij}$ describes the resource preference of the pair of species $(i,j)$, thus if $s_{ij}&gt;0$ species have preference for the same resources/environmental conditions, whereas they have opposite preference if $s_{ij}&lt;0$.</li> <li>$\\sigma_i$: is the strength of the environmental fluctuations experimented by each specie.</li> </ul> In\u00a0[107]: Copied! <pre>from scipy.stats import ortho_group\n\ndef EnvironmentalFilterMatrix(tau,sigmaNoise,S):\n\n\"\"\"\n        Function to create the correlation noise matrix given a paremeter set\n        - tau: dynamics scale;\n        - sigmaNoise (float): variance of the Gaussian noise;\n        - S: Total number of species\n        The correlation noise matrix must be symmetric and positive definite\n        \"\"\"\n    \n        U=ortho_group.rvs(dim=S)\n        L=np.diag(np.random.uniform(low=0,high=1,size=S))\n        D=np.matmul(U,np.matmul(L,U.T))\n        \n        D=D*sigmaNoise/tau\n        \n        return(D)\n</pre> from scipy.stats import ortho_group  def EnvironmentalFilterMatrix(tau,sigmaNoise,S):          \"\"\"         Function to create the correlation noise matrix given a paremeter set         - tau: dynamics scale;         - sigmaNoise (float): variance of the Gaussian noise;         - S: Total number of species         The correlation noise matrix must be symmetric and positive definite         \"\"\"              U=ortho_group.rvs(dim=S)         L=np.diag(np.random.uniform(low=0,high=1,size=S))         D=np.matmul(U,np.matmul(L,U.T))                  D=D*sigmaNoise/tau                  return(D) In\u00a0[108]: Copied! <pre>def StochasticLogisticEnviromentalFilter (b,K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S):\n\"\"\"\n    Stochastic Logistic equation with correlated noise (SLM) \n    solution by Euler-Maruyama method;\n    INPUT\n    - b: equivalent correlation Noise Matrix\n    - K (float): carrying capacitities;\n    - tau (float): intrinsic growth time;\n    - sigmaNoise (float): variance of the Gaussian noise;\n    - muNoise (float): mean value of the Gaussian noise;\n    - nSim (float): number of simulation;\n    - timeList (1d array): list of T time instants;\n    - abundanceStart (float): initial abundance;\n    - S (float): number of species;\n    OUTPUT\n    - longitudinal (T x S array): abundance of the species j at time i;\n    - crossSectional (S x nSim array): abundance of the k trajectory at the last time for the j trajectory;\n    \"\"\"\n    \n    #initial state\n    x0 = np.full(S,abundanceStart)\n\n    #simulation loop\n\n    abundanceMat = np.zeros((timeList.size,S,nSim),dtype=float)\n    \n    dt = round((timeList[-1]-timeList[0])/(len(timeList)),2)\n    \n    for sim in range(nSim):\n        \n        abundanceMat[0,:,sim] = x0\n        \n        #time loop\n        for t in range(1,timeList.size):\n\n            #dynamics\n            x = abundanceMat[t-1,:,sim]\n            z=np.random.normal(0,1,size=(S))\n            noise = muNoise+np.matmul(b,z)\n            xt = x+x*dt/tau-x**2/(tau*K)*dt+mt.sqrt(dt)*(noise*x) #equation\n        \n            abundanceMat[t,:,sim]=np.round(xt,5)\n    \n    longitudinal = abundanceMat[:,:,0]\n    crossSectional = abundanceMat[-1,:,:]\n    \n    return([longitudinal,crossSectional])\n</pre> def StochasticLogisticEnviromentalFilter (b,K,tau,sigmaNoise,muNoise,nSim,timeList,abundanceStart,S):          \"\"\"     Stochastic Logistic equation with correlated noise (SLM)      solution by Euler-Maruyama method;          INPUT     - b: equivalent correlation Noise Matrix     - K (float): carrying capacitities;     - tau (float): intrinsic growth time;     - sigmaNoise (float): variance of the Gaussian noise;     - muNoise (float): mean value of the Gaussian noise;     - nSim (float): number of simulation;     - timeList (1d array): list of T time instants;     - abundanceStart (float): initial abundance;     - S (float): number of species;          OUTPUT     - longitudinal (T x S array): abundance of the species j at time i;     - crossSectional (S x nSim array): abundance of the k trajectory at the last time for the j trajectory;     \"\"\"          #initial state     x0 = np.full(S,abundanceStart)      #simulation loop      abundanceMat = np.zeros((timeList.size,S,nSim),dtype=float)          dt = round((timeList[-1]-timeList[0])/(len(timeList)),2)          for sim in range(nSim):                  abundanceMat[0,:,sim] = x0                  #time loop         for t in range(1,timeList.size):              #dynamics             x = abundanceMat[t-1,:,sim]             z=np.random.normal(0,1,size=(S))             noise = muNoise+np.matmul(b,z)             xt = x+x*dt/tau-x**2/(tau*K)*dt+mt.sqrt(dt)*(noise*x) #equation                      abundanceMat[t,:,sim]=np.round(xt,5)          longitudinal = abundanceMat[:,:,0]     crossSectional = abundanceMat[-1,:,:]          return([longitudinal,crossSectional])"},{"location":"Synthetic-Communities/#getting-started-the-stochastic-logistic-model-slm","title":"Getting started: the Stochastic Logistic Model (SLM)\u00b6","text":"<p>Let us start by the simplest form of Eq. , when all species are independent and thus the interaction matrix are diagonal: $c_{ij}=0 \\hspace{1mm} \\forall i\\neq j$ and $s_{ij}=\\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker-delta.</p> $$ \\dot{x}_i=\\frac{x_i}{\\tau_i}\\left(1-\\frac{x_i}{K_i}\\right)+\\sqrt{\\frac{\\sigma_i}{\\tau_i}}x_i\\xi_i (t) $$<p>To integrate this equation we will use the well known Euler-Maruyama method:</p> $$ x(t_j)=x(t_{j-1})+h\\frac{x(t_{j-1})}{\\tau_i}[1-x_i(t_{j-1})/K_i]+\\sqrt{\\frac{h\\sigma_i}{\\tau_i}}x(t_{j-1})w_i $$<p>where:</p> <ul> <li>$i=1,\\dots,S$ runs over spcies</li> <li>$h$: is the integratio step, $h=\\frac{t_f-t_i}{N_t}$</li> <li>$j$: runs over time: $t_j=t_i+j\\cdot h$</li> <li>$w_i$ is a random variable normally distributed: $\\sim\\mathcal{N}(0,1)$</li> </ul> <p>The order of convergence of this algorithm over the trajectories is $O(h^{3/2})$</p>"},{"location":"Synthetic-Communities/#time-to-reach-the-steady-state","title":"Time to reach the steady state\u00b6","text":"<p>The solution of the deterministic part of the Logistic Model is given by:</p> $$ x(t)=\\frac{x_0e^{t/\\tau}}{1+\\left(\\frac{x_0}{K}\\left[e^{t/\\tau}-1\\right]\\right)} $$<p>where $x_0$. From this equation we can ask how long it takes for the system to approach the asymptote $x=K$ as close as we like, i.e., we define $t^\\star$ the time at which the abundance $x(t^\\star)=K-\\epsilon$ (where $\\epsilon$ is the distance to the asymptote):</p> $$ t^\\star=\\tau\\cdot log\\left[\\frac{(K-\\epsilon)}{\\epsilon}\\left(\\frac{K}{x_0}-1\\right)\\right] $$"},{"location":"Synthetic-Communities/#including-species-interactions","title":"Including species interactions\u00b6","text":""},{"location":"Synthetic-Communities/#feasibility-and-stability","title":"Feasibility and Stability\u00b6","text":""},{"location":"Synthetic-Communities/#environmental-filter-interaction","title":"Environmental filter interaction\u00b6","text":""},{"location":"Synthetic-Communities/#creating-environmental-filtering-matrix","title":"Creating environmental filtering matrix\u00b6","text":"<p>Diffusion matrix must be symmetric and positive definite. To this aim we can use a Singular Values Decomposition (SVD), which for symmetric matrix reads:</p> $$ D=U \\Lambda U^t $$<p>where $U$ is a orthogonal matrix $UU^t=\\mathbb{1}$ and $\\Lambda$ is a diagonal square matrix containing the eigenvalues,which must be all positive for a positive definite matrix. First, the $\\Lambda$ matrix can be set at random following a random distribuiton for positive values, for this example I have chose a uniform distribution between $[0,1]$ (you can try other distributions as gamma, beta or lognormal). For the orthogonal matrix $U$, we must draw them from the $O(N)$ Haar distribution, which is already prograed in python in the ortho_group.rvs function from the scipy library.</p> <p>Alternatively to function I propose bellow, you can also use the make_spd_matrix function from the sklearn library, however the random generator for the spectra will be always uniform.</p>"},{"location":"Synthetic-Communities/#running-simulations","title":"Running simulations\u00b6","text":""}]}